{
  parserClass="intellij.unison.language.parser.UnisonParser"
  parserUtilClass="intellij.unison.language.parser.UnisonParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Unison"
  psiImplClassSuffix="Impl"
  psiPackage="intellij.unison.language.psi"
  psiImplPackage="intellij.unison.language.psi.impl"

  elementTypeHolderClass="intellij.unison.language.psi.UnisonTypes"
  elementTypeClass="intellij.unison.language.psi.UnisonElementType"
  tokenTypeClass="intellij.unison.language.psi.UnisonTokenType"
}

unisonFile ::= statement*

statement ::= namespace_decl
            | use_import
            | topLevelTypeDefinition
            | binding
            | ability_decl
            | type_decl
            | definition
            | expression
            | COMMENT

namespace_decl ::= 'namespace' qualified_name

functionBody ::= ('do' expression) | statement+

use_import ::= 'use' ( qualified_import | qualified_name )

qualified_import ::= builtin_type ('.' IDENTIFIER)*

ability_decl ::= ( 'unique' | 'structural' )? 'ability' IDENTIFIER type_params? 'where' '{' ability_constructor* '}'

ability_constructor ::= IDENTIFIER ':' type_expr

type_decl ::= ( 'unique' | 'structural' )? 'type' qualified_name qualified_name? '=' constructor ( '|' constructor )*

constructor ::= qualified_name type_expr*

definition ::= 'let' (binding)+

topLevelTypeDefinition ::= qualified_name ':' ('''{' IDENTIFIER (',' IDENTIFIER )* '}')? type_expr functionBody

binding ::= qualified_name IDENTIFIER* '=' expression
  | (IDENTIFIER '=' expression)+
  | '(' literal (',' literal)* ')' '=' '(' expression (',' expression)* ')'

expression ::= lambda
             | num_expr
             | bool_expr
             | if_expr
             | match_expr
             | function_call
             | literal
             | qualified_name
             | qualified_import
             | '(' expression ')'

if_expr ::= 'if' bool_expr 'then' expression 'else' expression

match_expr ::= 'match' expression+ 'with' match_case+

num_expr ::=
   numLiteral NUM_OPERATOR numLiteral
   | numLiteral NUM_OPERATOR num_expr
   | IDENTIFIER NUM_OPERATOR num_expr
   | '-' num_expr
   | 'mod' num_expr num_expr
   | numLiteral
   | IDENTIFIER
   | '(' num_expr ')'

bool_expr ::=
   BOOLEAN BOOL_OPERATOR bool_expr
   | num_expr COMPARE_OPERATOR num_expr
   | 'not' bool_expr
   | num_expr '===' num_expr
   | bool_expr (BOOL_OPERATOR bool_expr)+
   | '(' bool_expr ')' (BOOL_OPERATOR bool_expr)+
   | BOOLEAN
   | IDENTIFIER

match_case ::= (pattern guard?)+ '->' expression

guard ::= '|' bool_expr

function_call ::= qualified_name '(' argument_list? ')'

argument_list ::= expression (',' expression)*

lambda ::= '\' pattern+ '->' expression

pattern ::= IDENTIFIER '@' pattern
          | IDENTIFIER
          | '_'
          | literal
          | constructor_pattern
          | '(' literal (',' literal)* ')'

constructor_pattern ::= IDENTIFIER pattern*

numLiteral ::= INT | DOUBLE

literal ::= INT
  | DOUBLE | CHAR | STRING | BOOLEAN | BYTES
  | '[' ']' | '[' literal (',' literal)* ']'
  | '(' literal (',' literal)* ')'

qualified_name ::= IDENTIFIER ('.' IDENTIFIER)*

builtin_type ::= 'Nat'
  | 'Int'
  | 'Char'
  | 'Text'
  | 'Float'
  | 'Double'
  | 'Boolean'
  | 'Bytes'
  | '()'

type_expr ::=
  '[' type_expr ']'
  | '[' IDENTIFIER ']' '->' type_expr IDENTIFIER?
  | builtin_type '->' type_expr
  | builtin_type
  | '(' type_expr (',' type_expr)* ')'
  | qualified_name

type_params ::= '{' IDENTIFIER (',' IDENTIFIER)* '}'

IDENTIFIER ::= IDENTIFIER_TOKEN
INT ::= INT_TOKEN
DOUBLE ::= DOUBLE_TOKEN
CHAR ::= CHAR_TOKEN
STRING ::= STRING_TOKEN
BYTES ::= BYTES_TOKEN
BOOLEAN ::= 'true' | 'false'
NUM_OPERATOR ::= NUM_OPERATOR_TOKEN
BOOL_OPERATOR ::= BOOL_OPERATOR_TOKEN
COMPARE_OPERATOR ::= COMPARE_OPERATOR_TOKEN
