{
  parserClass="intellij.unison.language.parser.UnisonParser"
  parserUtilClass="intellij.unison.language.parser.UnisonParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Unison"
  psiImplClassSuffix="Impl"
  psiPackage="intellij.unison.language.psi"
  psiImplPackage="intellij.unison.language.psi.impl"
  elementTypeHolderClass="intellij.unison.language.psi.UnisonTypes"
  elementTypeClass="intellij.unison.language.psi.UnisonElementType"
  tokenTypeClass="intellij.unison.language.psi.UnisonTokenType"

  tokens = [
    NAMESPACE='namespace'
    USE='use'
    ALIAS='alias'
    HANDLE='handle'
    CATCH='catch'
    ABILITY='ability'
    WHERE='where'
    TYPE='type'
    STRUCTURAL='structural'
    UNIQUE='unique'
    FORALL='forall'
    LET='let'
    DO='do'
    IF='if'
    THEN='then'
    ELSE='else'
    MATCH='match'
    WITH='with'
    CASES='cases'
    OTHERWISE='otherwise'

    AT='@'
    ARROW='->'
    COLON=':'
    EQ='='
    NOT='not'
    MODW='mod'
    BAR='|'
    COMMA=','
    LPAREN='('
    RPAREN=')'
    LPARENSQ='['
    RPARENSQ=']'
    LBRACE='{'
    RBRACE='}'
    DOT='.'
    BACKSLASH='\\'
    UNDERSCORE='_'
    FORALLSYMBOL='∀'

    KW_NAT='Nat'
    KW_INT='Int'
    KW_CHAR='Char'
    KW_TEXT='Text'
    KW_FLOAT='Float'
    KW_DOUBLE='Double'
    KW_BOOLEAN='Boolean'
    KW_BYTES='Bytes'
    KW_UNIT='()'

    BANG='!'
    CIAPEK="'"
    LBRACECIAPEK="'{"
    TYPELINK='typeLink'
    TERMLINK='termLink'
  ]
}

unisonFile ::= statement*

// https://www.unison-lang.org/docs/language-reference/top-level-declaration/
statement ::= MULTILINE_COMMENT_TOKEN
            | LINE_COMMENT_TOKEN
            | namespace_decl
            | ability_decl
            | dataType
            | expression

// https://www.unison-lang.org/docs/language-reference/namespace-declaration/
namespace_decl ::= 'namespace' qualified_name

fun_body ::= ('do' expression) | statement+

// https://www.unison-lang.org/docs/language-reference/use-clauses/
useClause ::= 'use' ( qualified_import | qualified_name | NUM_OPERATOR | BOOL_OPERATOR | COMPARE_OPERATOR )+

qualified_import ::= builtin_type ('.' IDENTIFIER)*

// https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#user-defined-abilities
ability_decl ::= ( 'unique' | 'structural' )? 'ability' IDENTIFIER type_params? 'where' '{' ability_constructor* '}'

ability_constructor ::= IDENTIFIER ':' type_expr

// https://www.unison-lang.org/docs/language-reference/user-defined-data-types/
dataType ::= ( 'unique' | 'structural' )? 'type' qualified_name qualified_name? '=' dataConstructor ( '|' dataConstructor )*

dataConstructor ::= qualified_name type_expr*

let_expr ::= 'let' (binding)+

// TODO typed_def requires work to use type annotation and (polymorphic)? term definition
// TODO current fun body is very arbitrary
// https://www.unison-lang.org/docs/language-reference/type-annotations/
// https://www.unison-lang.org/docs/language-reference/term-definition/
typed_def ::=
  qualified_name ':' polymorphicType? delayedType?
  type_expr ( '->' abilityRequirements type_expr )*
  fun_body

// https://www.unison-lang.org/docs/language-reference/delayed-computations/
delayedType ::= '''{' IDENTIFIER (',' IDENTIFIER )* '}'

// https://www.unison-lang.org/docs/language-reference/polymorphic-types/
polymorphicType ::= ('forall' | '∀') IDENTIFIER+ '.'

abilityRequirements ::= '{' IDENTIFIER (',' IDENTIFIER )* '}'

binding ::= qualified_name IDENTIFIER* '=' expression
  | ((IDENTIFIER | '_') '=' expression)+
  | '(' (IDENTIFIER | '_') (',' (IDENTIFIER | '_'))* ')' '=' '(' expression (',' expression)* ')'

// https://www.unison-lang.org/docs/language-reference/basic-lexical-forms/
expression ::= useClause
             | typed_def
             | binding
             | lambda
             | function_call
             | numExpr
             | boolExpr
             | ifThenElseExpr
             | matchExpr
             | cases_expr
             | literal
             | qualified_name
             | qualified_import
             | let_expr
             | catch_expr
             | '(' expression ')'

// https://www.unison-lang.org/docs/fundamentals/control-flow/if-then-and-else/#if-then-else
ifThenElseExpr ::= 'if' boolExpr 'then' expression 'else' expression

// https://www.unison-lang.org/docs/language-reference/match-expressions-and-pattern-matching/
matchExpr ::= 'match' expression+ 'with' match_case+

cases_expr ::= 'cases' expression+ (guardPattern '->' expression)+

match_case ::= (pattern (guardPattern '->' expression)+ | pattern '->' expression)+

catch_expr ::= 'catch' 'do' expression
  | 'catch' expression

// https://www.unison-lang.org/docs/language-reference/guard-patterns/
guardPattern ::= '|' ('otherwise' | boolExpr)

pattern ::= IDENTIFIER '@' pattern
          | IDENTIFIER
          | '_'
          | literal
          | constructor_pattern
          | '(' literal (',' literal)* ')'

numExpr ::=
   numLiteral NUM_OPERATOR numLiteral
   | numLiteral NUM_OPERATOR numExpr
   | IDENTIFIER NUM_OPERATOR numExpr
   | numLiteral NUM_OPERATOR IDENTIFIER
   | '-' numExpr
   | 'mod' numExpr numExpr
   | 'mod' numExpr IDENTIFIER
   | 'mod' IDENTIFIER numExpr
   | numLiteral
   | '(' numExpr ')'

// https://www.unison-lang.org/docs/language-reference/boolean-expressions/
boolExpr ::=
   IDENTIFIER '>' numLiteral
   | IDENTIFIER '<' numLiteral
   | numLiteral '===' IDENTIFIER
   | IDENTIFIER '===' numExpr
   | BOOLEAN BOOL_OPERATOR boolExpr
   | IDENTIFIER COMPARE_OPERATOR numExpr
   | numExpr COMPARE_OPERATOR numExpr
   | 'not' boolExpr
   | numExpr '===' numExpr
   | boolExpr (BOOL_OPERATOR boolExpr)+
   | '(' boolExpr ')' (BOOL_OPERATOR boolExpr)+
   | BOOLEAN
   | IDENTIFIER

function_call ::= qualified_name '(' argument_list? ')'

argument_list ::= expression (',' expression)*

lambda ::= pattern+ '->' expression

constructor_pattern ::= IDENTIFIER pattern*

numLiteral ::= INT | DOUBLE

// https://www.unison-lang.org/docs/language-reference/literals/
literal ::= INT
  | DOUBLE | CHAR | STRING | BOOLEAN | BYTES
  | '[' ']' | '[' literal (',' literal)* ']'
  | '(' literal (',' literal)* ')'

// https://www.unison-lang.org/docs/language-reference/identifiers/#namespace-qualified-identifiers
qualified_name ::= IDENTIFIER ('.' IDENTIFIER)*

// TODO Any Doc Either IPattern Ordering Optional Pattern Pretty Uuid Void
// https://share.unison-lang.org/@unison/website/code/main/latest/namespaces/lib/base/;/types/Uuid
builtin_type ::= KW_NAT
  | KW_INT
  | KW_CHAR
  | KW_TEXT
  | KW_FLOAT
  | KW_DOUBLE
  | KW_BOOLEAN
  | KW_BYTES
  | KW_UNIT

type_expr ::=
  '[' type_expr IDENTIFIER? ']'
  | builtin_type '->' type_expr IDENTIFIER?
  | IDENTIFIER '->' type_expr IDENTIFIER?
  | '[' IDENTIFIER ']' '->' type_expr IDENTIFIER?
  | builtin_type
  | '(' type_expr IDENTIFIER? (',' type_expr IDENTIFIER?)* ')'
  | qualified_name

type_params ::= '{' IDENTIFIER (',' IDENTIFIER)* '}'

IDENTIFIER ::= IDENTIFIER_TOKEN
INT ::= INT_TOKEN
DOUBLE ::= DOUBLE_TOKEN
CHAR ::= CHAR_TOKEN
STRING ::= STRING_TOKEN
BYTES ::= BYTES_TOKEN
BOOLEAN ::= BOOLEAN_TOKEN
NUM_OPERATOR ::= NUM_OPERATOR_TOKEN
BOOL_OPERATOR ::= BOOL_OPERATOR_TOKEN
COMPARE_OPERATOR ::= COMPARE_OPERATOR_TOKEN
