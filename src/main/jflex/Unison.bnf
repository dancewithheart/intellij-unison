{
  parserClass="intellij.unison.language.parser.UnisonParser"
  parserUtilClass="intellij.unison.language.parser.UnisonParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Unison"
  psiImplClassSuffix="Impl"
  psiPackage="intellij.unison.language.psi"
  psiImplPackage="intellij.unison.language.psi.impl"

  elementTypeHolderClass="intellij.unison.language.psi.UnisonTypes"
  elementTypeClass="intellij.unison.language.psi.UnisonElementType"
  tokenTypeClass="intellij.unison.language.psi.UnisonTokenType"
}

unisonFile ::= statement*

statement ::= COMMENT
            | namespace_decl
            | ability_decl
            | type_decl
            | expression

namespace_decl ::= 'namespace' qualified_name

fun_body ::= ('do' expression) | statement+

use_import ::= 'use' ( qualified_import | qualified_name | NUM_OPERATOR | BOOL_OPERATOR | COMPARE_OPERATOR )+

qualified_import ::= builtin_type ('.' IDENTIFIER)*

ability_decl ::= ( 'unique' | 'structural' )? 'ability' IDENTIFIER type_params? 'where' '{' ability_constructor* '}'

ability_constructor ::= IDENTIFIER ':' type_expr

type_decl ::= ( 'unique' | 'structural' )? 'type' qualified_name qualified_name? '=' constructor ( '|' constructor )*

constructor ::= qualified_name type_expr*

let_expr ::= 'let' (binding)+

typed_def ::=
  qualified_name ':' (('forall' | 'âˆ€') IDENTIFIER+ '.')?
    ('''{' IDENTIFIER (',' IDENTIFIER )* '}')?
    type_expr ( '->' '{' IDENTIFIER (',' IDENTIFIER )* '}' type_expr )*
    fun_body

binding ::= qualified_name IDENTIFIER* '=' expression
  | ((IDENTIFIER | '_') '=' expression)+
  | '(' (IDENTIFIER | '_') (',' (IDENTIFIER | '_'))* ')' '=' '(' expression (',' expression)* ')'

expression ::= use_import
             | typed_def
             | binding
             | lambda
             | function_call
             | num_expr
             | bool_expr
             | if_expr
             | match_expr
             | cases_expr
             | literal
             | qualified_name
             | qualified_import
             | let_expr
             | catch_expr
             | '(' expression ')'

if_expr ::= 'if' bool_expr 'then' expression 'else' expression

match_expr ::= 'match' expression+ 'with' match_case+

cases_expr ::= 'cases' expression+ (guard '->' expression)+

match_case ::= (pattern (guard '->' expression)+ | pattern '->' expression)+

catch_expr ::= 'catch' 'do' expression
  | 'catch' expression

guard ::= '|' ('otherwise' | bool_expr)

pattern ::= IDENTIFIER '@' pattern
          | IDENTIFIER
          | '_'
          | literal
          | constructor_pattern
          | '(' literal (',' literal)* ')'

num_expr ::=
   numLiteral NUM_OPERATOR numLiteral
   | numLiteral NUM_OPERATOR num_expr
   | IDENTIFIER NUM_OPERATOR num_expr
   | numLiteral NUM_OPERATOR IDENTIFIER
   | '-' num_expr
   | 'mod' num_expr num_expr
   | 'mod' num_expr IDENTIFIER
   | 'mod' IDENTIFIER num_expr
   | numLiteral
   | '(' num_expr ')'

bool_expr ::=
   IDENTIFIER '>' numLiteral
   | IDENTIFIER '<' numLiteral
   | numLiteral '===' IDENTIFIER
   | IDENTIFIER '===' num_expr
   | BOOLEAN BOOL_OPERATOR bool_expr
   | IDENTIFIER COMPARE_OPERATOR num_expr
   | num_expr COMPARE_OPERATOR num_expr
   | 'not' bool_expr
   | num_expr '===' num_expr
   | bool_expr (BOOL_OPERATOR bool_expr)+
   | '(' bool_expr ')' (BOOL_OPERATOR bool_expr)+
   | BOOLEAN
   | IDENTIFIER

function_call ::= qualified_name '(' argument_list? ')'

argument_list ::= expression (',' expression)*

lambda ::= pattern+ '->' expression

constructor_pattern ::= IDENTIFIER pattern*

numLiteral ::= INT | DOUBLE

literal ::= INT
  | DOUBLE | CHAR | STRING | BOOLEAN | BYTES
  | '[' ']' | '[' literal (',' literal)* ']'
  | '(' literal (',' literal)* ')'

qualified_name ::= IDENTIFIER ('.' IDENTIFIER)*

builtin_type ::= 'Nat'
  | 'Int'
  | 'Char'
  | 'Text'
  | 'Float'
  | 'Double'
  | 'Boolean'
  | 'Bytes'
  | '()'

type_expr ::=
  '[' type_expr IDENTIFIER? ']'
  | builtin_type '->' type_expr IDENTIFIER?
  | IDENTIFIER '->' type_expr IDENTIFIER?
  | '[' IDENTIFIER ']' '->' type_expr IDENTIFIER?
  | builtin_type
  | '(' type_expr IDENTIFIER? (',' type_expr IDENTIFIER?)* ')'
  | qualified_name

type_params ::= '{' IDENTIFIER (',' IDENTIFIER)* '}'

COMMENT ::= COMMENT_TOKEN
IDENTIFIER ::= IDENTIFIER_TOKEN
INT ::= INT_TOKEN
DOUBLE ::= DOUBLE_TOKEN
CHAR ::= CHAR_TOKEN
STRING ::= STRING_TOKEN
BYTES ::= BYTES_TOKEN
BOOLEAN ::= 'true' | 'false'
NUM_OPERATOR ::= NUM_OPERATOR_TOKEN
BOOL_OPERATOR ::= BOOL_OPERATOR_TOKEN
COMPARE_OPERATOR ::= COMPARE_OPERATOR_TOKEN
