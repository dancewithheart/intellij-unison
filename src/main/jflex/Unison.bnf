{
  parserClass="intellij.unison.language.parser.UnisonParser"
  parserUtilClass="intellij.unison.language.parser.UnisonParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  psiClassPrefix="Unison"
  psiImplClassSuffix="Impl"
  psiPackage="intellij.unison.language.psi"
  psiImplPackage="intellij.unison.language.psi.impl"
  elementTypeHolderClass="intellij.unison.language.psi.UnisonTypes"
  elementTypeClass="intellij.unison.language.psi.UnisonElementType"
  tokenTypeClass="intellij.unison.language.psi.UnisonTokenType"
  root="unisonFile"
  tokens = [
    NAMESPACE='namespace'
    USE='use'
    ALIAS='alias'
    HANDLE='handle'
    CATCH='catch'
    ABILITY='ability'
    WHERE='where'
    TYPE='type'
    STRUCTURAL='structural'
    UNIQUE='unique'
    FORALL='forall'
    LET='let'
    DO='do'
    IF='if'
    THEN='then'
    ELSE='else'
    MATCH='match'
    WITH='with'
    CASES='cases'
    OTHERWISE='otherwise'

    AT='@'
    ARROW='->'
    COLON=':'
    EQ='='
    NOT='not'
    MODW='mod'
    BAR='|'
    COMMA=','
    LPAREN='('
    RPAREN=')'
    LPARENSQ='['
    RPARENSQ=']'
    LBRACE='{'
    RBRACE='}'
    DOT='.'
    BACKSLASH='\\'
    UNDERSCORE='_'
    FORALLSYMBOL='âˆ€'

    KW_NAT='Nat'
    KW_INT='Int'
    KW_CHAR='Char'
    KW_TEXT='Text'
    KW_FLOAT='Float'
    KW_DOUBLE='Double'
    KW_BOOLEAN='Boolean'
    KW_BYTES='Bytes'
    KW_UNIT='()'

    BANG='!'
    TICK="'"
    LBRACETICK="'{"
    TYPELINK='typeLink'
    TERMLINK='termLink'
  ]
}

unisonFile ::= statement*

private name ::= IDENTIFIER | OPERATOR_ID

// https://www.unison-lang.org/docs/language-reference/top-level-declaration/
statement ::= MULTILINE_COMMENT_TOKEN
            | LINE_COMMENT_TOKEN
            | namespace_decl
            | ability_decl
            | dataType
            | expression

// https://www.unison-lang.org/docs/language-reference/namespace-declaration/
namespace_decl ::= NAMESPACE qualified_name

fun_body ::= (DO expression) | statement+

// https://www.unison-lang.org/docs/language-reference/use-clauses/
useClause ::= USE (qualified_import
 | qualified_name
 | NUM_OPERATOR
 | BOOL_OPERATOR
 | COMPARE_OPERATOR )+

private qualified_import ::= builtin_type (DOT IDENTIFIER)*

// https://www.unison-lang.org/docs/language-reference/identifiers/#namespace-qualified-identifiers
private qualified_name ::= name (DOT name)*

// https://www.unison-lang.org/docs/language-reference/abilities-and-ability-handlers/#user-defined-abilities
ability_decl ::= (UNIQUE | STRUCTURAL)? ABILITY IDENTIFIER type_params?
 WHERE LBRACE ability_constructor* RBRACE

private ability_constructor ::= IDENTIFIER COLON type_expr

// https://www.unison-lang.org/docs/language-reference/user-defined-data-types/
dataType ::= (UNIQUE | STRUCTURAL)? TYPE qualified_name qualified_name? EQ
  dataConstructor (BAR dataConstructor)*

dataConstructor ::= qualified_name type_expr*

let_expr ::= LET (binding)+

// TODO typed_def requires work to use type annotation and (polymorphic)? term definition
// TODO current fun body is very arbitrary
// https://www.unison-lang.org/docs/language-reference/type-annotations/
// https://www.unison-lang.org/docs/language-reference/term-definition/
typed_def ::=
  qualified_name COLON polymorphicType? delayedType?
  type_expr (ARROW abilityRequirements type_expr)*
  fun_body

// https://www.unison-lang.org/docs/language-reference/delayed-computations/
delayedType ::= LBRACETICK IDENTIFIER (COMMA IDENTIFIER)* RBRACE

// https://www.unison-lang.org/docs/language-reference/polymorphic-types/
polymorphicType ::= (FORALL | FORALLSYMBOL) IDENTIFIER+ DOT

private abilityRequirements ::= LBRACE IDENTIFIER (COMMA IDENTIFIER )* RBRACE

binding ::= qualified_name IDENTIFIER* EQ expression
  | ((IDENTIFIER | UNDERSCORE) EQ expression)+
  | LPAREN (IDENTIFIER | UNDERSCORE) (COMMA (IDENTIFIER | UNDERSCORE))* RPAREN EQ LPAREN expression (COMMA expression)* RPAREN

// https://www.unison-lang.org/docs/language-reference/basic-lexical-forms/
expression ::= useClause
             | typed_def
             | binding
             | lambda
             | function_call
             | numExpr
             | boolExpr
             | ifThenElseExpr
             | matchExpr
             | cases_expr
             | literal
             | qualified_name
             | qualified_import
             | let_expr
             | catch_expr
             | LPAREN expression RPAREN

// https://www.unison-lang.org/docs/fundamentals/control-flow/if-then-and-else/#if-then-else
ifThenElseExpr ::= IF boolExpr THEN expression ELSE expression

// https://www.unison-lang.org/docs/language-reference/match-expressions-and-pattern-matching/
matchExpr ::= MATCH expression+ WITH match_case+

cases_expr ::= CASES expression+ (guardPattern ARROW expression)+

match_case ::= (pattern (guardPattern ARROW expression)+ | pattern ARROW expression)+

catch_expr ::= CATCH DO expression
  | CATCH expression

// https://www.unison-lang.org/docs/language-reference/guard-patterns/
guardPattern ::= BAR (OTHERWISE | boolExpr)

pattern ::= name AT pattern
          | name
          | UNDERSCORE
          | literal
          | constructor_pattern
          | LPAREN literal (COMMA literal)* RPAREN

numExpr ::= sumExpr

private sumExpr ::= prodExpr (NUM_OPERATOR prodExpr)*
private prodExpr ::= unaryExpr (NUM_OPERATOR unaryExpr)*

private unaryExpr ::=
    MINUS unaryExpr
  | MODW unaryExpr unaryExpr
  | atomNum

private atomNum ::=
    numLiteral
  | qualified_name
  | LPAREN numExpr RPAREN

private numLiteral ::= INT | DOUBLE
private MINUS ::= NUM_OPERATOR

// https://www.unison-lang.org/docs/language-reference/boolean-expressions/
boolExpr ::= orExpr

private orExpr  ::= andExpr (BOOL_OPERATOR andExpr)*
private andExpr ::= notExpr (BOOL_OPERATOR notExpr)*

private notExpr ::=
    NOT notExpr
  | boolAtom

private boolAtom ::=
    BOOLEAN
  | comparison
  | LPAREN boolExpr RPAREN

private comparison ::=
    numExpr COMPARE_OPERATOR numExpr
  | qualified_name COMPARE_OPERATOR numExpr
  | numExpr COMPARE_OPERATOR qualified_name
  | qualified_name COMPARE_OPERATOR qualified_name

function_call ::= qualified_name LPAREN argument_list? RPAREN

private argument_list ::= expression (COMMA expression)*

lambda ::= pattern+ ARROW expression

private constructor_pattern ::= name pattern*

// https://www.unison-lang.org/docs/language-reference/literals/
literal ::= INT
  | DOUBLE | CHAR | STRING | BOOLEAN | BYTES
  | LPARENSQ RPARENSQ
  | LPARENSQ literal (COMMA literal)* RPARENSQ
  | LPAREN literal (COMMA literal)* RPAREN

// TODO Any Doc Either IPattern Ordering Optional Pattern Pretty Uuid Void
// https://share.unison-lang.org/@unison/website/code/main/latest/namespaces/lib/base/;/types/Uuid
builtin_type ::= KW_NAT
  | KW_INT
  | KW_CHAR
  | KW_TEXT
  | KW_FLOAT
  | KW_DOUBLE
  | KW_BOOLEAN
  | KW_BYTES
  | KW_UNIT

type_expr ::=
  LPARENSQ type_expr IDENTIFIER? RPARENSQ
  | builtin_type ARROW type_expr IDENTIFIER?
  | IDENTIFIER ARROW type_expr IDENTIFIER?
  | LPARENSQ IDENTIFIER RPARENSQ ARROW type_expr IDENTIFIER?
  | builtin_type
  | LPAREN type_expr IDENTIFIER? (COMMA type_expr IDENTIFIER?)* RPAREN
  | qualified_name

private type_params ::= LBRACE IDENTIFIER (COMMA IDENTIFIER)* RBRACE

IDENTIFIER ::= IDENTIFIER_TOKEN
OPERATOR_ID ::= OPERATOR_ID_TOKEN
INT ::= INT_TOKEN
DOUBLE ::= DOUBLE_TOKEN
CHAR ::= CHAR_TOKEN
STRING ::= STRING_TOKEN
BYTES ::= BYTES_TOKEN
BOOLEAN ::= BOOLEAN_TOKEN
NUM_OPERATOR ::= NUM_OPERATOR_TOKEN
BOOL_OPERATOR ::= BOOL_OPERATOR_TOKEN
COMPARE_OPERATOR ::= COMPARE_OPERATOR_TOKEN
