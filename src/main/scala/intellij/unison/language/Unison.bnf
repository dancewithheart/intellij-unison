{
  parserClass="intellij.unison.language.parser.UnisonParser"
  parserUtilClass="intellij.unison.language.parser.UnisonParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Unison"
  psiImplClassSuffix="Impl"
  psiPackage="intellij.unison.language.psi"
  psiImplPackage="intellij.unison.language.psi.impl"

  elementTypeHolderClass="intellij.unison.language.psi.UnisonTypes"
  elementTypeClass="intellij.unison.language.psi.UnisonElementType"
  tokenTypeClass="intellij.unison.language.psi.UnisonTokenType"
}

unisonFile ::= statement*

statement ::= namespace_decl
            | use_import
            | topLevelDefinition
            | ability_decl
            | type_decl
            | definition
            | expression
            | comment

namespace_decl ::= 'namespace' qualified_name

use_import ::= 'use' qualified_name ('.' '*')?

ability_decl ::= ( 'unique' | 'structural' )? 'ability' IDENTIFIER type_params? 'where' '{' ability_constructor* '}'

ability_constructor ::= IDENTIFIER ':' type_expr

type_decl ::= ( 'unique' | 'structural' )? 'type' qualified_name type_params? '=' constructor ( '|' constructor )*

constructor ::= qualified_name type_expr*

definition ::= 'let' (IDENTIFIER '=' expression)+

topLevelDefinition ::= IDENTIFIER '=' expression

expression ::= literal
             | IDENTIFIER
             | qualified_name
             | function_call
             | lambda
             | num_expr
             | if_expr
             | match_expr
             | '(' expression ')'

if_expr ::= 'if' expression 'then' expression 'else' expression

match_expr ::= 'match' expression 'with' match_case+

num_expr ::= ( IDENTIFIER | numLiteral ) OPERATOR ( IDENTIFIER | numLiteral )
   | '-' ( IDENTIFIER | numLiteral )
   | IDENTIFIER ( IDENTIFIER | numLiteral )*

match_case ::= '|' pattern '->' expression

function_call ::= IDENTIFIER '(' argument_list? ')'

argument_list ::= expression (',' expression)*

lambda ::= '\' pattern '->' expression

pattern ::= IDENTIFIER
          | '_'
          | literal
          | constructor_pattern
          | '(' pattern ')'

constructor_pattern ::= IDENTIFIER pattern*

numLiteral ::= INT | DOUBLE

literal ::= INT | DOUBLE | CHAR | TEXT | BOOLEAN

qualified_name ::= IDENTIFIER ('.' IDENTIFIER)*

type_expr ::= IDENTIFIER | '(' type_expr ')' | type_expr '->' type_expr

type_params ::= '{' IDENTIFIER (',' IDENTIFIER)* '}'

IDENTIFIER ::= IDENTIFIER_TOKEN
INT ::= INT_TOKEN
DOUBLE ::= DOUBLE_TOKEN
CHAR ::= CHAR_TOKEN
TEXT ::= TEXT_TOKEN
BOOLEAN ::= 'true' | 'false'
OPERATOR ::= OPERATOR_TOKEN

