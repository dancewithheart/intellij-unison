{
  parserClass="intellij.unison.language.parser.UnisonParser"
  parserUtilClass="intellij.unison.language.parser.UnisonParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Unison"
  psiImplClassSuffix="Impl"
  psiPackage="intellij.unison.language.psi"
  psiImplPackage="intellij.unison.language.psi.impl"

  elementTypeHolderClass="intellij.unison.language.psi.UnisonTypes"
  elementTypeClass="intellij.unison.language.psi.UnisonElementType"
  tokenTypeClass="intellij.unison.language.psi.UnisonTokenType"
}

unisonFile ::= statement*

statement ::= namespace_decl
            | use_import
            | topLevelTypeDefinition
            | binding
            | ability_decl
            | type_decl
            | definition
            | expression
            | COMMENT

namespace_decl ::= 'namespace' qualified_name

use_import ::= 'use' qualified_name ('.' '*')?

ability_decl ::= ( 'unique' | 'structural' )? 'ability' IDENTIFIER type_params? 'where' '{' ability_constructor* '}'

ability_constructor ::= IDENTIFIER ':' type_expr

type_decl ::= ( 'unique' | 'structural' )? 'type' qualified_name qualified_name? '=' constructor ( '|' constructor )*

constructor ::= qualified_name type_expr*

definition ::= 'let' (binding)+

topLevelTypeDefinition ::= qualified_name ':' ('''{' IDENTIFIER (',' IDENTIFIER )* '}')? type_expr

binding ::= qualified_name IDENTIFIER* '=' expression
  | (IDENTIFIER '=' expression)+
  | '(' literal (',' literal)* ')' '=' '(' expression (',' expression)* ')'

expression ::= literal
             | lambda
             | num_expr
             | bool_expr
             | if_expr
             | match_expr
             | function_call
             | qualified_name
             | '(' expression ')'

if_expr ::= 'if' bool_expr 'then' expression 'else' expression

match_expr ::= 'match' expression 'with' match_case+

num_expr ::= numLiteral
   | numLiteral NUM_OPERATOR num_expr
   | '-' num_expr
   | '(' num_expr ')'

bool_expr ::= BOOLEAN
   | BOOLEAN BOOL_OPERATOR bool_expr
   | 'not' bool_expr
   | 'mod' bool_expr bool_expr
   | '(' bool_expr ')'

match_case ::= '|' pattern '->' expression

function_call ::= qualified_name '(' argument_list? ')'

argument_list ::= expression (',' expression)*

lambda ::= '\' pattern '->' expression

pattern ::= IDENTIFIER
          | '_'
          | literal
          | constructor_pattern
          | '(' pattern ')'

constructor_pattern ::= IDENTIFIER pattern*

numLiteral ::= INT | DOUBLE

literal ::= INT
  | DOUBLE | CHAR | STRING | BOOLEAN
  | '[' ']' | '[' literal (',' literal)* ']'
  | '(' literal (',' literal)* ')'

qualified_name ::= IDENTIFIER ('.' IDENTIFIER)*

builtin_type ::= 'Nat'
  | 'Int'
  | 'Char'
  | 'Text'
  | 'Float'
  | 'Double'
  | 'Boolean'
  | 'Bytes'
  | '()'
  | '[' builtin_type ']'

type_expr ::= builtin_type
  | qualified_name
  | builtin_type '->' builtin_type
  | '(' type_expr (',' type_expr)* ')'

type_params ::= '{' IDENTIFIER (',' IDENTIFIER)* '}'

IDENTIFIER ::= IDENTIFIER_TOKEN
INT ::= INT_TOKEN
DOUBLE ::= DOUBLE_TOKEN
CHAR ::= CHAR_TOKEN
STRING ::= STRING_TOKEN
BOOLEAN ::= 'true' | 'false'
NUM_OPERATOR ::= NUM_OPERATOR_TOKEN
BOOL_OPERATOR ::= BOOL_OPERATOR_TOKEN

