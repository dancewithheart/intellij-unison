-- comments https://www.unison-lang.org/docs/language-reference/comments/

-- top level declaration docs: https://www.unison-lang.org/docs/language-reference/top-level-declaration/
-- namespace declaration
namespace models.User

-- use clause
use math sqrt

-- top level term declaration
foo = 42
bar = true
baz = "live"
quux = [1, 2, 3,]

-- if then else
coinflip : Boolean -> Text
coinflip bool = if bool then longText else "Hi"

-- delayed computation
myFunction : '{IO, Exception} Text
myFunction arg = do "special keyword" ++ arg

longText1 : () -> Text
longText1 _ = "Imagine infinite monkeys on infinite typewriters …"

longText2 : 'Text
longText2 = do "Imagine infinite monkeys on infinite typewriters …"

!longText2

{-
Top level type declaration
https://www.unison-lang.org/docs/language-reference/user-defined-data-types/

<unique|structural<[<regular-identifier>]?>?> type TypeConstructor p1 p2 … pn
  = DataConstructor_1
  | DataConstructor_2
  ..
  | DataConstructor_n

-}
structural type Optional a
  = lib.base.Optional.Some a
  | lib.base.Optional.None

type UserId
  = docs.languageReference.userDefinedDataTypes.UserId.Phone Nat
  | docs.languageReference.userDefinedDataTypes.UserId.Email Text

-- term declaration (term binding)
{-
https://www.unison-lang.org/docs/language-reference/term-declarations/

name : Type
name p_1 p_2 … p_n = expression
-}
timesTwo : Nat -> Nat  -- type signature
timesTwo x = x * 2     -- term definition

-- ability-declaration
-- https://www.unison-lang.org/docs/language-reference/ability-declaration/
{-
unique|structural ability A p_1 p_2 … p_n where
    Request_1 : Type_1
    Request_2 : Type_2
    Request_n : Type_n
-}
structural ability Throw e where
  lib.base.abilities.Throw.throw : e ->{Throw e} a

-- operators
-- !$%^&*-=+<>~\\/|:

(^) x y = Nat.pow x y

-- block expressions
{-
statement_1
statement_2
…
statement_n
expression
-}
let
  x = 1
  y = 2
  x + y

-- TODO literals
1
"hello"
[1, 2, 3]

-- pattern matching

{-
https://www.unison-lang.org/docs/language-reference/match-expressions-and-pattern-matching/

match e with
  pattern_1 -> block_1
  pattern_2 -> block_2
  …
  pattern_n -> block_n

cases
  pattern_1 -> block_1
  pattern_2 -> block_1
  …
  pattern_n -> block_n

-}

-- literal patterns
match 2 Nat.+ 2 with
  4 -> "Matches"
  _ -> "Doesn't match"

-- as patterns
matchExpression : Nat
matchExpression = match 1 Nat.+ 1 with
  x@4 -> x Nat.* 2
  y@2 -> y Nat.+ 1
  _   -> 22

-- constructor patterns
xs = [0, 2, 3, 4, 5]
match List.at 3 xs with
  Optional.None -> 0
  Some x        -> x

-- list patterns
first : [a] -> Optional a
first = cases
  h +: _ -> Some h
  []     -> None

-- tuple patterns

(a, _, c) = (1, 2, 3)
a Nat.+ c

-- guard patterns

match 1 + 2 with
  x
    | x == 4     -> 0
    | x + 1 == 4 -> 6
  _              -> 42
